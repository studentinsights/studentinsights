# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: true
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/site_ruby/all/site_ruby.rbi
#
# site_ruby-2.5.0
class Bundler::Thor
  def self.banner(command, namespace = nil, subcommand = nil); end
  def self.baseclass; end
  def self.check_unknown_options!(options = nil); end
  def self.check_unknown_options?(config); end
  def self.command_help(shell, command_name); end
  def self.create_command(meth); end
  def self.create_task(meth); end
  def self.default_command(meth = nil); end
  def self.default_task(meth = nil); end
  def self.desc(usage, description, options = nil); end
  def self.disable_required_check!(*command_names); end
  def self.disable_required_check; end
  def self.disable_required_check?(command); end
  def self.dispatch(meth, given_args, given_opts, config); end
  def self.dynamic_command_class; end
  def self.find_command_possibilities(meth); end
  def self.find_task_possibilities(meth); end
  def self.help(shell, subcommand = nil); end
  def self.initialize_added; end
  def self.long_desc(long_description, options = nil); end
  def self.map(mappings = nil); end
  def self.method_option(name, options = nil); end
  def self.method_options(options = nil); end
  def self.normalize_command_name(meth); end
  def self.normalize_task_name(meth); end
  def self.option(name, options = nil); end
  def self.options(options = nil); end
  def self.package_name(name, _ = nil); end
  def self.printable_commands(all = nil, subcommand = nil); end
  def self.printable_tasks(all = nil, subcommand = nil); end
  def self.register(klass, subcommand_name, usage, description, options = nil); end
  def self.retrieve_command_name(args); end
  def self.retrieve_task_name(args); end
  def self.stop_on_unknown_option!(*command_names); end
  def self.stop_on_unknown_option; end
  def self.stop_on_unknown_option?(command); end
  def self.subcommand(subcommand, subcommand_class); end
  def self.subcommand_classes; end
  def self.subcommand_help(cmd); end
  def self.subcommands; end
  def self.subtask(subcommand, subcommand_class); end
  def self.subtask_help(cmd); end
  def self.subtasks; end
  def self.task_help(shell, command_name); end
  extend Bundler::Thor::Base::ClassMethods
  extend Bundler::Thor::Invocation::ClassMethods
  include Bundler::Thor::Base
  include Bundler::Thor::Invocation
  include Bundler::Thor::Shell
end
class Anonymous_Struct_40 < Struct
  def ancestor_name; end
  def ancestor_name=(_); end
  def description; end
  def description=(_); end
  def long_description; end
  def long_description=(_); end
  def name; end
  def name=(_); end
  def options; end
  def options=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.members; end
  def self.new(*arg0); end
  def usage; end
  def usage=(_); end
end
class Bundler::Thor::Command < Anonymous_Struct_40
  def formatted_usage(klass, namespace = nil, subcommand = nil); end
  def handle_argument_error?(instance, error, caller); end
  def handle_no_method_error?(instance, error, caller); end
  def hidden?; end
  def initialize(name, description, long_description, usage, options = nil); end
  def initialize_copy(other); end
  def local_method?(instance, name); end
  def not_debugging?(instance); end
  def private_method?(instance); end
  def public_method?(instance); end
  def required_options; end
  def run(instance, args = nil); end
  def sans_backtrace(backtrace, caller); end
end
class Bundler::Thor::HiddenCommand < Bundler::Thor::Command
  def hidden?; end
end
class Bundler::Thor::DynamicCommand < Bundler::Thor::Command
  def initialize(name, options = nil); end
  def run(instance, args = nil); end
end
module Bundler::Thor::CoreExt
end
class Bundler::Thor::CoreExt::HashWithIndifferentAccess < Hash
  def [](key); end
  def []=(key, value); end
  def convert_key(key); end
  def delete(key); end
  def fetch(key, *args); end
  def initialize(hash = nil); end
  def key?(key); end
  def merge!(other); end
  def merge(other); end
  def method_missing(method, *args); end
  def replace(other_hash); end
  def reverse_merge!(other_hash); end
  def reverse_merge(other); end
  def to_hash; end
  def values_at(*indices); end
end
class Bundler::Thor::CoreExt::OrderedHash < Hash
end
class Bundler::Thor::Error < StandardError
end
class Bundler::Thor::UndefinedCommandError < Bundler::Thor::Error
end
class Bundler::Thor::AmbiguousCommandError < Bundler::Thor::Error
end
class Bundler::Thor::InvocationError < Bundler::Thor::Error
end
class Bundler::Thor::UnknownArgumentError < Bundler::Thor::Error
end
class Bundler::Thor::RequiredArgumentMissingError < Bundler::Thor::InvocationError
end
class Bundler::Thor::MalformattedArgumentError < Bundler::Thor::InvocationError
end
module Bundler::Thor::Invocation
  def _parse_initialization_options(args, opts, config); end
  def _retrieve_class_and_command(name, sent_command = nil); end
  def _retrieve_class_and_task(name, sent_command = nil); end
  def _shared_configuration; end
  def current_command_chain; end
  def initialize(args = nil, options = nil, config = nil, &block); end
  def invoke(name = nil, *args); end
  def invoke_all; end
  def invoke_command(command, *args); end
  def invoke_task(command, *args); end
  def invoke_with_padding(*args); end
  def self.included(base); end
end
module Bundler::Thor::Invocation::ClassMethods
  def prepare_for_invocation(key, name); end
end
class Bundler::Thor::Argument
  def banner; end
  def default; end
  def default_banner; end
  def description; end
  def enum; end
  def human_name; end
  def initialize(name, options = nil); end
  def name; end
  def required; end
  def required?; end
  def show_default?; end
  def type; end
  def usage; end
  def valid_type?(type); end
  def validate!; end
end
class Bundler::Thor::Arguments
  def check_requirement!; end
  def current_is_value?; end
  def initialize(arguments = nil); end
  def last?; end
  def no_or_skip?(arg); end
  def parse(args); end
  def parse_array(name); end
  def parse_hash(name); end
  def parse_numeric(name); end
  def parse_string(name); end
  def peek; end
  def remaining; end
  def self.parse(*args); end
  def self.split(args); end
  def shift; end
  def unshift(arg); end
end
class Bundler::Thor::Option < Bundler::Thor::Argument
  def aliases; end
  def array?; end
  def boolean?; end
  def dasherize(str); end
  def dasherized?; end
  def group; end
  def hash?; end
  def hide; end
  def human_name; end
  def initialize(name, options = nil); end
  def lazy_default; end
  def numeric?; end
  def self.parse(key, value); end
  def string?; end
  def switch_name; end
  def undasherize(str); end
  def usage(padding = nil); end
  def validate!; end
  def validate_default_type!; end
end
class Bundler::Thor::Options < Bundler::Thor::Arguments
  def check_unknown!; end
  def current_is_switch?; end
  def current_is_switch_formatted?; end
  def current_is_value?; end
  def initialize(hash_options = nil, defaults = nil, stop_on_unknown = nil, disable_required_check = nil); end
  def normalize_switch(arg); end
  def parse(args); end
  def parse_boolean(switch); end
  def parse_peek(switch, option); end
  def parsing_options?; end
  def peek; end
  def remaining; end
  def self.to_switches(options); end
  def switch?(arg); end
  def switch_option(arg); end
end
module Bundler::Thor::Base
  def args; end
  def args=(arg0); end
  def initialize(args = nil, local_options = nil, config = nil); end
  def options; end
  def options=(arg0); end
  def parent_options; end
  def parent_options=(arg0); end
  def self.included(base); end
  def self.register_klass_file(klass); end
  def self.shell; end
  def self.shell=(arg0); end
  def self.subclass_files; end
  def self.subclasses; end
end
module Bundler::Thor::Shell
  def _shared_configuration; end
  def ask(*args, &block); end
  def error(*args, &block); end
  def file_collision(*args, &block); end
  def initialize(args = nil, options = nil, config = nil); end
  def no?(*args, &block); end
  def print_in_columns(*args, &block); end
  def print_table(*args, &block); end
  def print_wrapped(*args, &block); end
  def say(*args, &block); end
  def say_status(*args, &block); end
  def set_color(*args, &block); end
  def shell; end
  def shell=(arg0); end
  def terminal_width(*args, &block); end
  def with_padding; end
  def yes?(*args, &block); end
end
module Bundler::Thor::LineEditor
  def self.best_available; end
  def self.readline(prompt, options = nil); end
end
class Bundler::Thor::LineEditor::Basic
  def echo?; end
  def get_input; end
  def initialize(prompt, options); end
  def options; end
  def prompt; end
  def readline; end
  def self.available?; end
end
class Bundler::Thor::LineEditor::Readline < Bundler::Thor::LineEditor::Basic
  def add_to_history?; end
  def completion_options; end
  def completion_proc; end
  def readline; end
  def self.available?; end
  def use_path_completion?; end
end
class Bundler::Thor::LineEditor::Readline::PathCompletion
  def absolute_matches; end
  def base_path; end
  def glob_pattern; end
  def initialize(text); end
  def matches; end
  def relative_matches; end
  def text; end
end
module Bundler::Thor::Sandbox
end
module Bundler::Thor::Util
  def self.camel_case(str); end
  def self.escape_globs(path); end
  def self.find_by_namespace(namespace); end
  def self.find_class_and_command_by_namespace(namespace, fallback = nil); end
  def self.find_class_and_task_by_namespace(namespace, fallback = nil); end
  def self.globs_for(path); end
  def self.load_thorfile(path, content = nil, debug = nil); end
  def self.namespace_from_thor_class(constant); end
  def self.namespaces_in_content(contents, file = nil); end
  def self.ruby_command; end
  def self.snake_case(str); end
  def self.thor_classes_in(klass); end
  def self.thor_root; end
  def self.thor_root_glob; end
  def self.user_home; end
end
module Bundler::Thor::Base::ClassMethods
  def all_commands; end
  def all_tasks; end
  def argument(name, options = nil); end
  def arguments; end
  def attr_accessor(*arg0); end
  def attr_reader(*arg0); end
  def attr_writer(*arg0); end
  def baseclass; end
  def basename; end
  def build_option(name, options, scope); end
  def build_options(options, scope); end
  def check_default_type!; end
  def check_default_type; end
  def check_default_type?; end
  def check_unknown_options!; end
  def check_unknown_options; end
  def check_unknown_options?(config); end
  def class_option(name, options = nil); end
  def class_options(options = nil); end
  def class_options_help(shell, groups = nil); end
  def commands; end
  def create_command(meth); end
  def create_task(meth); end
  def disable_required_check?(command_name); end
  def dispatch(command, given_args, given_opts, config); end
  def exit_on_failure?; end
  def find_and_refresh_command(name); end
  def find_and_refresh_task(name); end
  def from_superclass(method, default = nil); end
  def group(name = nil); end
  def handle_argument_error(command, error, args, arity); end
  def handle_no_command_error(command, has_namespace = nil); end
  def handle_no_task_error(command, has_namespace = nil); end
  def inherited(klass); end
  def initialize_added; end
  def is_thor_reserved_word?(word, type); end
  def method_added(meth); end
  def namespace(name = nil); end
  def no_commands; end
  def no_tasks; end
  def print_options(shell, options, group_name = nil); end
  def public_command(*names); end
  def public_task(*names); end
  def remove_argument(*names); end
  def remove_class_option(*names); end
  def remove_command(*names); end
  def remove_task(*names); end
  def start(given_args = nil, config = nil); end
  def stop_on_unknown_option?(command_name); end
  def strict_args_position!; end
  def strict_args_position; end
  def strict_args_position?(config); end
  def tasks; end
end
module Bundler
  def self.require_thor_actions; end
end
